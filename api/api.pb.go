// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: api/api.proto

package api

import (
	context "context"
	encoding_binary "encoding/binary"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	io "io"
	math "math"
	crew "ultre.me/calcbiz/pkg/crew"
	soundcloud "ultre.me/calcbiz/pkg/soundcloud"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion2 // please upgrade the proto package

type Void struct {
}

func (m *Void) Reset()         { *m = Void{} }
func (m *Void) String() string { return proto.CompactTextString(m) }
func (*Void) ProtoMessage()    {}
func (*Void) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{0}
}
func (m *Void) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Void) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Void.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Void) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Void.Merge(m, src)
}
func (m *Void) XXX_Size() int {
	return m.Size()
}
func (m *Void) XXX_DiscardUnknown() {
	xxx_messageInfo_Void.DiscardUnknown(m)
}

var xxx_messageInfo_Void proto.InternalMessageInfo

type Pong struct {
	Pong string `protobuf:"bytes,1,opt,name=pong,proto3" json:"pong,omitempty"`
}

func (m *Pong) Reset()         { *m = Pong{} }
func (m *Pong) String() string { return proto.CompactTextString(m) }
func (*Pong) ProtoMessage()    {}
func (*Pong) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{1}
}
func (m *Pong) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Pong) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Pong.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Pong) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Pong.Merge(m, src)
}
func (m *Pong) XXX_Size() int {
	return m.Size()
}
func (m *Pong) XXX_DiscardUnknown() {
	xxx_messageInfo_Pong.DiscardUnknown(m)
}

var xxx_messageInfo_Pong proto.InternalMessageInfo

func (m *Pong) GetPong() string {
	if m != nil {
		return m.Pong
	}
	return ""
}

type KryptosInput struct {
	From string `protobuf:"bytes,1,opt,name=from,proto3" json:"from,omitempty"`
}

func (m *KryptosInput) Reset()         { *m = KryptosInput{} }
func (m *KryptosInput) String() string { return proto.CompactTextString(m) }
func (*KryptosInput) ProtoMessage()    {}
func (*KryptosInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{2}
}
func (m *KryptosInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KryptosInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KryptosInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KryptosInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KryptosInput.Merge(m, src)
}
func (m *KryptosInput) XXX_Size() int {
	return m.Size()
}
func (m *KryptosInput) XXX_DiscardUnknown() {
	xxx_messageInfo_KryptosInput.DiscardUnknown(m)
}

var xxx_messageInfo_KryptosInput proto.InternalMessageInfo

func (m *KryptosInput) GetFrom() string {
	if m != nil {
		return m.From
	}
	return ""
}

type KryptosOutput struct {
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *KryptosOutput) Reset()         { *m = KryptosOutput{} }
func (m *KryptosOutput) String() string { return proto.CompactTextString(m) }
func (*KryptosOutput) ProtoMessage()    {}
func (*KryptosOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{3}
}
func (m *KryptosOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KryptosOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KryptosOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KryptosOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KryptosOutput.Merge(m, src)
}
func (m *KryptosOutput) XXX_Size() int {
	return m.Size()
}
func (m *KryptosOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_KryptosOutput.DiscardUnknown(m)
}

var xxx_messageInfo_KryptosOutput proto.InternalMessageInfo

func (m *KryptosOutput) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

// tpyo megasess
type TpyoEnocdeIpunt struct {
	Form string `protobuf:"bytes,1,opt,name=form,proto3" json:"form,omitempty"`
}

func (m *TpyoEnocdeIpunt) Reset()         { *m = TpyoEnocdeIpunt{} }
func (m *TpyoEnocdeIpunt) String() string { return proto.CompactTextString(m) }
func (*TpyoEnocdeIpunt) ProtoMessage()    {}
func (*TpyoEnocdeIpunt) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{4}
}
func (m *TpyoEnocdeIpunt) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TpyoEnocdeIpunt) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TpyoEnocdeIpunt.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TpyoEnocdeIpunt) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TpyoEnocdeIpunt.Merge(m, src)
}
func (m *TpyoEnocdeIpunt) XXX_Size() int {
	return m.Size()
}
func (m *TpyoEnocdeIpunt) XXX_DiscardUnknown() {
	xxx_messageInfo_TpyoEnocdeIpunt.DiscardUnknown(m)
}

var xxx_messageInfo_TpyoEnocdeIpunt proto.InternalMessageInfo

func (m *TpyoEnocdeIpunt) GetForm() string {
	if m != nil {
		return m.Form
	}
	return ""
}

type TpyoEnocdeOuptut struct {
	To string `protobuf:"bytes,1,opt,name=to,proto3" json:"to,omitempty"`
}

func (m *TpyoEnocdeOuptut) Reset()         { *m = TpyoEnocdeOuptut{} }
func (m *TpyoEnocdeOuptut) String() string { return proto.CompactTextString(m) }
func (*TpyoEnocdeOuptut) ProtoMessage()    {}
func (*TpyoEnocdeOuptut) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{5}
}
func (m *TpyoEnocdeOuptut) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TpyoEnocdeOuptut) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TpyoEnocdeOuptut.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TpyoEnocdeOuptut) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TpyoEnocdeOuptut.Merge(m, src)
}
func (m *TpyoEnocdeOuptut) XXX_Size() int {
	return m.Size()
}
func (m *TpyoEnocdeOuptut) XXX_DiscardUnknown() {
	xxx_messageInfo_TpyoEnocdeOuptut.DiscardUnknown(m)
}

var xxx_messageInfo_TpyoEnocdeOuptut proto.InternalMessageInfo

func (m *TpyoEnocdeOuptut) GetTo() string {
	if m != nil {
		return m.To
	}
	return ""
}

type DahsboardRandomOutput struct {
}

func (m *DahsboardRandomOutput) Reset()         { *m = DahsboardRandomOutput{} }
func (m *DahsboardRandomOutput) String() string { return proto.CompactTextString(m) }
func (*DahsboardRandomOutput) ProtoMessage()    {}
func (*DahsboardRandomOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{6}
}
func (m *DahsboardRandomOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DahsboardRandomOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DahsboardRandomOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DahsboardRandomOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DahsboardRandomOutput.Merge(m, src)
}
func (m *DahsboardRandomOutput) XXX_Size() int {
	return m.Size()
}
func (m *DahsboardRandomOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DahsboardRandomOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DahsboardRandomOutput proto.InternalMessageInfo

type DahsboardOutput struct {
}

func (m *DahsboardOutput) Reset()         { *m = DahsboardOutput{} }
func (m *DahsboardOutput) String() string { return proto.CompactTextString(m) }
func (*DahsboardOutput) ProtoMessage()    {}
func (*DahsboardOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{7}
}
func (m *DahsboardOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DahsboardOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DahsboardOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DahsboardOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DahsboardOutput.Merge(m, src)
}
func (m *DahsboardOutput) XXX_Size() int {
	return m.Size()
}
func (m *DahsboardOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DahsboardOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DahsboardOutput proto.InternalMessageInfo

type DashboardOutput struct {
}

func (m *DashboardOutput) Reset()         { *m = DashboardOutput{} }
func (m *DashboardOutput) String() string { return proto.CompactTextString(m) }
func (*DashboardOutput) ProtoMessage()    {}
func (*DashboardOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{8}
}
func (m *DashboardOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *DashboardOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_DashboardOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *DashboardOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DashboardOutput.Merge(m, src)
}
func (m *DashboardOutput) XXX_Size() int {
	return m.Size()
}
func (m *DashboardOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_DashboardOutput.DiscardUnknown(m)
}

var xxx_messageInfo_DashboardOutput proto.InternalMessageInfo

// numberinfo messages
type NumberinfoInput struct {
	Number float32 `protobuf:"fixed32,1,opt,name=number,proto3" json:"number,omitempty"`
}

func (m *NumberinfoInput) Reset()         { *m = NumberinfoInput{} }
func (m *NumberinfoInput) String() string { return proto.CompactTextString(m) }
func (*NumberinfoInput) ProtoMessage()    {}
func (*NumberinfoInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{9}
}
func (m *NumberinfoInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberinfoInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberinfoInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumberinfoInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberinfoInput.Merge(m, src)
}
func (m *NumberinfoInput) XXX_Size() int {
	return m.Size()
}
func (m *NumberinfoInput) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberinfoInput.DiscardUnknown(m)
}

var xxx_messageInfo_NumberinfoInput proto.InternalMessageInfo

func (m *NumberinfoInput) GetNumber() float32 {
	if m != nil {
		return m.Number
	}
	return 0
}

type NumberinfoOutput struct {
	Facts map[string]string `protobuf:"bytes,1,rep,name=facts,proto3" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
}

func (m *NumberinfoOutput) Reset()         { *m = NumberinfoOutput{} }
func (m *NumberinfoOutput) String() string { return proto.CompactTextString(m) }
func (*NumberinfoOutput) ProtoMessage()    {}
func (*NumberinfoOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{10}
}
func (m *NumberinfoOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *NumberinfoOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_NumberinfoOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *NumberinfoOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NumberinfoOutput.Merge(m, src)
}
func (m *NumberinfoOutput) XXX_Size() int {
	return m.Size()
}
func (m *NumberinfoOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_NumberinfoOutput.DiscardUnknown(m)
}

var xxx_messageInfo_NumberinfoOutput proto.InternalMessageInfo

func (m *NumberinfoOutput) GetFacts() map[string]string {
	if m != nil {
		return m.Facts
	}
	return nil
}

type MoijaimeOutput struct {
	Kiffs []string `protobuf:"bytes,1,rep,name=kiffs,proto3" json:"kiffs,omitempty"`
}

func (m *MoijaimeOutput) Reset()         { *m = MoijaimeOutput{} }
func (m *MoijaimeOutput) String() string { return proto.CompactTextString(m) }
func (*MoijaimeOutput) ProtoMessage()    {}
func (*MoijaimeOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{11}
}
func (m *MoijaimeOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MoijaimeOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MoijaimeOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MoijaimeOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MoijaimeOutput.Merge(m, src)
}
func (m *MoijaimeOutput) XXX_Size() int {
	return m.Size()
}
func (m *MoijaimeOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_MoijaimeOutput.DiscardUnknown(m)
}

var xxx_messageInfo_MoijaimeOutput proto.InternalMessageInfo

func (m *MoijaimeOutput) GetKiffs() []string {
	if m != nil {
		return m.Kiffs
	}
	return nil
}

type WotdOutput struct {
	Word string `protobuf:"bytes,1,opt,name=word,proto3" json:"word,omitempty"`
}

func (m *WotdOutput) Reset()         { *m = WotdOutput{} }
func (m *WotdOutput) String() string { return proto.CompactTextString(m) }
func (*WotdOutput) ProtoMessage()    {}
func (*WotdOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{12}
}
func (m *WotdOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *WotdOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_WotdOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *WotdOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_WotdOutput.Merge(m, src)
}
func (m *WotdOutput) XXX_Size() int {
	return m.Size()
}
func (m *WotdOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_WotdOutput.DiscardUnknown(m)
}

var xxx_messageInfo_WotdOutput proto.InternalMessageInfo

func (m *WotdOutput) GetWord() string {
	if m != nil {
		return m.Word
	}
	return ""
}

type AlternateLogoOutput struct {
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
}

func (m *AlternateLogoOutput) Reset()         { *m = AlternateLogoOutput{} }
func (m *AlternateLogoOutput) String() string { return proto.CompactTextString(m) }
func (*AlternateLogoOutput) ProtoMessage()    {}
func (*AlternateLogoOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{13}
}
func (m *AlternateLogoOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AlternateLogoOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AlternateLogoOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AlternateLogoOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AlternateLogoOutput.Merge(m, src)
}
func (m *AlternateLogoOutput) XXX_Size() int {
	return m.Size()
}
func (m *AlternateLogoOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_AlternateLogoOutput.DiscardUnknown(m)
}

var xxx_messageInfo_AlternateLogoOutput proto.InternalMessageInfo

func (m *AlternateLogoOutput) GetPath() string {
	if m != nil {
		return m.Path
	}
	return ""
}

type SpreadshirtRandomOutput struct {
}

func (m *SpreadshirtRandomOutput) Reset()         { *m = SpreadshirtRandomOutput{} }
func (m *SpreadshirtRandomOutput) String() string { return proto.CompactTextString(m) }
func (*SpreadshirtRandomOutput) ProtoMessage()    {}
func (*SpreadshirtRandomOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{14}
}
func (m *SpreadshirtRandomOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadshirtRandomOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadshirtRandomOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadshirtRandomOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadshirtRandomOutput.Merge(m, src)
}
func (m *SpreadshirtRandomOutput) XXX_Size() int {
	return m.Size()
}
func (m *SpreadshirtRandomOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadshirtRandomOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadshirtRandomOutput proto.InternalMessageInfo

type SpreadshirtAllOutput struct {
}

func (m *SpreadshirtAllOutput) Reset()         { *m = SpreadshirtAllOutput{} }
func (m *SpreadshirtAllOutput) String() string { return proto.CompactTextString(m) }
func (*SpreadshirtAllOutput) ProtoMessage()    {}
func (*SpreadshirtAllOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{15}
}
func (m *SpreadshirtAllOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SpreadshirtAllOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SpreadshirtAllOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SpreadshirtAllOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SpreadshirtAllOutput.Merge(m, src)
}
func (m *SpreadshirtAllOutput) XXX_Size() int {
	return m.Size()
}
func (m *SpreadshirtAllOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_SpreadshirtAllOutput.DiscardUnknown(m)
}

var xxx_messageInfo_SpreadshirtAllOutput proto.InternalMessageInfo

type SoundcloudPlaylistInput struct {
	PlaylistId uint64 `protobuf:"varint,1,opt,name=playlist_id,json=playlistId,proto3" json:"playlist_id,omitempty"`
}

func (m *SoundcloudPlaylistInput) Reset()         { *m = SoundcloudPlaylistInput{} }
func (m *SoundcloudPlaylistInput) String() string { return proto.CompactTextString(m) }
func (*SoundcloudPlaylistInput) ProtoMessage()    {}
func (*SoundcloudPlaylistInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{16}
}
func (m *SoundcloudPlaylistInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SoundcloudPlaylistInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SoundcloudPlaylistInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SoundcloudPlaylistInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SoundcloudPlaylistInput.Merge(m, src)
}
func (m *SoundcloudPlaylistInput) XXX_Size() int {
	return m.Size()
}
func (m *SoundcloudPlaylistInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SoundcloudPlaylistInput.DiscardUnknown(m)
}

var xxx_messageInfo_SoundcloudPlaylistInput proto.InternalMessageInfo

func (m *SoundcloudPlaylistInput) GetPlaylistId() uint64 {
	if m != nil {
		return m.PlaylistId
	}
	return 0
}

type SoundcloudTrackInput struct {
	TrackId uint64 `protobuf:"varint,1,opt,name=track_id,json=trackId,proto3" json:"track_id,omitempty"`
}

func (m *SoundcloudTrackInput) Reset()         { *m = SoundcloudTrackInput{} }
func (m *SoundcloudTrackInput) String() string { return proto.CompactTextString(m) }
func (*SoundcloudTrackInput) ProtoMessage()    {}
func (*SoundcloudTrackInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{17}
}
func (m *SoundcloudTrackInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *SoundcloudTrackInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_SoundcloudTrackInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *SoundcloudTrackInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SoundcloudTrackInput.Merge(m, src)
}
func (m *SoundcloudTrackInput) XXX_Size() int {
	return m.Size()
}
func (m *SoundcloudTrackInput) XXX_DiscardUnknown() {
	xxx_messageInfo_SoundcloudTrackInput.DiscardUnknown(m)
}

var xxx_messageInfo_SoundcloudTrackInput proto.InternalMessageInfo

func (m *SoundcloudTrackInput) GetTrackId() uint64 {
	if m != nil {
		return m.TrackId
	}
	return 0
}

type RecettatorInput struct {
	Seed                 int64  `protobuf:"varint,1,opt,name=seed,proto3" json:"seed,omitempty"`
	MainIngredients      uint64 `protobuf:"varint,2,opt,name=main_ingredients,json=mainIngredients,proto3" json:"main_ingredients,omitempty"`
	SecondaryIngredients uint64 `protobuf:"varint,3,opt,name=secondary_ingredients,json=secondaryIngredients,proto3" json:"secondary_ingredients,omitempty"`
	Steps                uint64 `protobuf:"varint,4,opt,name=steps,proto3" json:"steps,omitempty"`
}

func (m *RecettatorInput) Reset()         { *m = RecettatorInput{} }
func (m *RecettatorInput) String() string { return proto.CompactTextString(m) }
func (*RecettatorInput) ProtoMessage()    {}
func (*RecettatorInput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{18}
}
func (m *RecettatorInput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecettatorInput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecettatorInput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecettatorInput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecettatorInput.Merge(m, src)
}
func (m *RecettatorInput) XXX_Size() int {
	return m.Size()
}
func (m *RecettatorInput) XXX_DiscardUnknown() {
	xxx_messageInfo_RecettatorInput.DiscardUnknown(m)
}

var xxx_messageInfo_RecettatorInput proto.InternalMessageInfo

func (m *RecettatorInput) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func (m *RecettatorInput) GetMainIngredients() uint64 {
	if m != nil {
		return m.MainIngredients
	}
	return 0
}

func (m *RecettatorInput) GetSecondaryIngredients() uint64 {
	if m != nil {
		return m.SecondaryIngredients
	}
	return 0
}

func (m *RecettatorInput) GetSteps() uint64 {
	if m != nil {
		return m.Steps
	}
	return 0
}

type RecettatorIngredient struct {
	Name            string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Quantity        string `protobuf:"bytes,2,opt,name=quantity,proto3" json:"quantity,omitempty"`
	Method          string `protobuf:"bytes,3,opt,name=method,proto3" json:"method,omitempty"`
	Gender          string `protobuf:"bytes,4,opt,name=gender,proto3" json:"gender,omitempty"`
	Multiple        bool   `protobuf:"varint,5,opt,name=multiple,proto3" json:"multiple,omitempty"`
	Kind            string `protobuf:"bytes,6,opt,name=kind,proto3" json:"kind,omitempty"`
	NameAndQuantity string `protobuf:"bytes,7,opt,name=name_and_quantity,json=nameAndQuantity,proto3" json:"name_and_quantity,omitempty"`
}

func (m *RecettatorIngredient) Reset()         { *m = RecettatorIngredient{} }
func (m *RecettatorIngredient) String() string { return proto.CompactTextString(m) }
func (*RecettatorIngredient) ProtoMessage()    {}
func (*RecettatorIngredient) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{19}
}
func (m *RecettatorIngredient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecettatorIngredient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecettatorIngredient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecettatorIngredient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecettatorIngredient.Merge(m, src)
}
func (m *RecettatorIngredient) XXX_Size() int {
	return m.Size()
}
func (m *RecettatorIngredient) XXX_DiscardUnknown() {
	xxx_messageInfo_RecettatorIngredient.DiscardUnknown(m)
}

var xxx_messageInfo_RecettatorIngredient proto.InternalMessageInfo

func (m *RecettatorIngredient) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *RecettatorIngredient) GetQuantity() string {
	if m != nil {
		return m.Quantity
	}
	return ""
}

func (m *RecettatorIngredient) GetMethod() string {
	if m != nil {
		return m.Method
	}
	return ""
}

func (m *RecettatorIngredient) GetGender() string {
	if m != nil {
		return m.Gender
	}
	return ""
}

func (m *RecettatorIngredient) GetMultiple() bool {
	if m != nil {
		return m.Multiple
	}
	return false
}

func (m *RecettatorIngredient) GetKind() string {
	if m != nil {
		return m.Kind
	}
	return ""
}

func (m *RecettatorIngredient) GetNameAndQuantity() string {
	if m != nil {
		return m.NameAndQuantity
	}
	return ""
}

type RecettatorOutput struct {
	Title                string                  `protobuf:"bytes,1,opt,name=title,proto3" json:"title,omitempty"`
	People               uint64                  `protobuf:"varint,2,opt,name=people,proto3" json:"people,omitempty"`
	Markdown             string                  `protobuf:"bytes,3,opt,name=markdown,proto3" json:"markdown,omitempty"`
	Steps                []string                `protobuf:"bytes,4,rep,name=steps,proto3" json:"steps,omitempty"`
	MainIngredients      []*RecettatorIngredient `protobuf:"bytes,5,rep,name=main_ingredients,json=mainIngredients,proto3" json:"main_ingredients,omitempty"`
	SecondaryIngredients []*RecettatorIngredient `protobuf:"bytes,6,rep,name=secondary_ingredients,json=secondaryIngredients,proto3" json:"secondary_ingredients,omitempty"`
	Seed                 int64                   `protobuf:"varint,7,opt,name=seed,proto3" json:"seed,omitempty"`
}

func (m *RecettatorOutput) Reset()         { *m = RecettatorOutput{} }
func (m *RecettatorOutput) String() string { return proto.CompactTextString(m) }
func (*RecettatorOutput) ProtoMessage()    {}
func (*RecettatorOutput) Descriptor() ([]byte, []int) {
	return fileDescriptor_1b40cafcd4234784, []int{20}
}
func (m *RecettatorOutput) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *RecettatorOutput) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_RecettatorOutput.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *RecettatorOutput) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RecettatorOutput.Merge(m, src)
}
func (m *RecettatorOutput) XXX_Size() int {
	return m.Size()
}
func (m *RecettatorOutput) XXX_DiscardUnknown() {
	xxx_messageInfo_RecettatorOutput.DiscardUnknown(m)
}

var xxx_messageInfo_RecettatorOutput proto.InternalMessageInfo

func (m *RecettatorOutput) GetTitle() string {
	if m != nil {
		return m.Title
	}
	return ""
}

func (m *RecettatorOutput) GetPeople() uint64 {
	if m != nil {
		return m.People
	}
	return 0
}

func (m *RecettatorOutput) GetMarkdown() string {
	if m != nil {
		return m.Markdown
	}
	return ""
}

func (m *RecettatorOutput) GetSteps() []string {
	if m != nil {
		return m.Steps
	}
	return nil
}

func (m *RecettatorOutput) GetMainIngredients() []*RecettatorIngredient {
	if m != nil {
		return m.MainIngredients
	}
	return nil
}

func (m *RecettatorOutput) GetSecondaryIngredients() []*RecettatorIngredient {
	if m != nil {
		return m.SecondaryIngredients
	}
	return nil
}

func (m *RecettatorOutput) GetSeed() int64 {
	if m != nil {
		return m.Seed
	}
	return 0
}

func init() {
	proto.RegisterType((*Void)(nil), "calcbiz.server.Void")
	proto.RegisterType((*Pong)(nil), "calcbiz.server.Pong")
	proto.RegisterType((*KryptosInput)(nil), "calcbiz.server.KryptosInput")
	proto.RegisterType((*KryptosOutput)(nil), "calcbiz.server.KryptosOutput")
	proto.RegisterType((*TpyoEnocdeIpunt)(nil), "calcbiz.server.TpyoEnocdeIpunt")
	proto.RegisterType((*TpyoEnocdeOuptut)(nil), "calcbiz.server.TpyoEnocdeOuptut")
	proto.RegisterType((*DahsboardRandomOutput)(nil), "calcbiz.server.DahsboardRandomOutput")
	proto.RegisterType((*DahsboardOutput)(nil), "calcbiz.server.DahsboardOutput")
	proto.RegisterType((*DashboardOutput)(nil), "calcbiz.server.DashboardOutput")
	proto.RegisterType((*NumberinfoInput)(nil), "calcbiz.server.NumberinfoInput")
	proto.RegisterType((*NumberinfoOutput)(nil), "calcbiz.server.NumberinfoOutput")
	proto.RegisterMapType((map[string]string)(nil), "calcbiz.server.NumberinfoOutput.FactsEntry")
	proto.RegisterType((*MoijaimeOutput)(nil), "calcbiz.server.MoijaimeOutput")
	proto.RegisterType((*WotdOutput)(nil), "calcbiz.server.WotdOutput")
	proto.RegisterType((*AlternateLogoOutput)(nil), "calcbiz.server.AlternateLogoOutput")
	proto.RegisterType((*SpreadshirtRandomOutput)(nil), "calcbiz.server.SpreadshirtRandomOutput")
	proto.RegisterType((*SpreadshirtAllOutput)(nil), "calcbiz.server.SpreadshirtAllOutput")
	proto.RegisterType((*SoundcloudPlaylistInput)(nil), "calcbiz.server.SoundcloudPlaylistInput")
	proto.RegisterType((*SoundcloudTrackInput)(nil), "calcbiz.server.SoundcloudTrackInput")
	proto.RegisterType((*RecettatorInput)(nil), "calcbiz.server.RecettatorInput")
	proto.RegisterType((*RecettatorIngredient)(nil), "calcbiz.server.RecettatorIngredient")
	proto.RegisterType((*RecettatorOutput)(nil), "calcbiz.server.RecettatorOutput")
}

func init() { proto.RegisterFile("api/api.proto", fileDescriptor_1b40cafcd4234784) }

var fileDescriptor_1b40cafcd4234784 = []byte{
	// 1278 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x57, 0x41, 0x6f, 0x13, 0xc7,
	0x17, 0x67, 0x1d, 0x27, 0x24, 0x0f, 0x62, 0x3b, 0x93, 0x4d, 0xe2, 0x2c, 0xc1, 0x09, 0x03, 0xff,
	0x3f, 0x84, 0x0a, 0x5b, 0x85, 0x0b, 0xe2, 0x96, 0x42, 0x2a, 0x45, 0x94, 0x42, 0x0d, 0x2d, 0x2a,
	0x97, 0x68, 0xe3, 0x9d, 0xac, 0x17, 0xef, 0xce, 0x2c, 0xb3, 0xb3, 0x44, 0x2e, 0xca, 0xa5, 0xe7,
	0x4a, 0xad, 0xd4, 0x63, 0xbf, 0x45, 0xbf, 0x42, 0x2f, 0x3d, 0xa2, 0xf6, 0xd2, 0x63, 0x05, 0xfd,
	0x20, 0xd5, 0xcc, 0xac, 0x77, 0x9c, 0x5d, 0x2f, 0x55, 0x0f, 0xbd, 0x44, 0xf3, 0xde, 0xfc, 0xe6,
	0xf7, 0x7b, 0xf3, 0xe6, 0x79, 0xdf, 0x0b, 0x2c, 0xbb, 0x71, 0xd0, 0x73, 0xe3, 0xa0, 0x1b, 0x73,
	0x26, 0x18, 0x6a, 0x0c, 0xdc, 0x70, 0x70, 0x14, 0x7c, 0xd3, 0x4d, 0x08, 0x7f, 0x4d, 0xb8, 0xb3,
	0xe5, 0x33, 0xe6, 0x87, 0xa4, 0xa7, 0x50, 0x94, 0x32, 0xe1, 0x8a, 0x80, 0xd1, 0x44, 0xa3, 0x9d,
	0x5b, 0x7e, 0x20, 0x86, 0xe9, 0x51, 0x77, 0xc0, 0xa2, 0x9e, 0xcf, 0x7c, 0xd6, 0x53, 0xee, 0xa3,
	0xf4, 0x58, 0x59, 0xca, 0x50, 0xab, 0x0c, 0xbe, 0x1a, 0x8f, 0xfc, 0xde, 0x80, 0x93, 0x13, 0xf5,
	0x27, 0x73, 0x6e, 0x4b, 0x67, 0xc2, 0x52, 0xea, 0x0d, 0x42, 0x96, 0x7a, 0x53, 0x4b, 0x0d, 0xc0,
	0x0b, 0x50, 0xff, 0x8a, 0x05, 0x1e, 0x76, 0xa0, 0xfe, 0x84, 0x51, 0x1f, 0x21, 0xa8, 0xc7, 0x8c,
	0xfa, 0x6d, 0x6b, 0xc7, 0xba, 0xb1, 0xd4, 0x57, 0x6b, 0x8c, 0xe1, 0xe2, 0x43, 0x3e, 0x8e, 0x05,
	0x4b, 0x0e, 0x68, 0x9c, 0x0a, 0x89, 0x39, 0xe6, 0x2c, 0x9a, 0x60, 0xe4, 0x1a, 0x6f, 0xc3, 0x72,
	0x86, 0x79, 0x9c, 0x0a, 0x09, 0x6a, 0x40, 0x4d, 0xb0, 0x0c, 0x52, 0x13, 0x0c, 0xff, 0x0f, 0x9a,
	0xcf, 0xe2, 0x31, 0xdb, 0xa7, 0x6c, 0xe0, 0x91, 0x83, 0x38, 0xa5, 0x9a, 0x87, 0x71, 0xc3, 0xc3,
	0x78, 0x84, 0x31, 0xb4, 0x0c, 0xec, 0x71, 0x1a, 0x8b, 0x19, 0x54, 0x1b, 0xb0, 0xf6, 0xc0, 0x1d,
	0x26, 0x47, 0xcc, 0xe5, 0x5e, 0xdf, 0xa5, 0x1e, 0x8b, 0xb4, 0x26, 0x5e, 0x81, 0x66, 0xbe, 0x31,
	0xed, 0x4a, 0x86, 0xd3, 0xae, 0x5d, 0x68, 0x7e, 0x9e, 0x46, 0x47, 0x84, 0x07, 0xf4, 0x98, 0xe9,
	0x1b, 0xad, 0xc3, 0x02, 0x55, 0x2e, 0xa5, 0x52, 0xeb, 0x67, 0x16, 0xfe, 0xde, 0x82, 0x96, 0xc1,
	0x66, 0x37, 0xdb, 0x83, 0xf9, 0x63, 0x77, 0x20, 0x92, 0xb6, 0xb5, 0x33, 0x77, 0xe3, 0xc2, 0xed,
	0x8f, 0xba, 0x67, 0x5f, 0xb5, 0x5b, 0x3c, 0xd0, 0xfd, 0x54, 0xa2, 0xf7, 0xa9, 0xe0, 0xe3, 0xbe,
	0x3e, 0xe9, 0xdc, 0x05, 0x30, 0x4e, 0xd4, 0x82, 0xb9, 0x11, 0x19, 0x67, 0x17, 0x94, 0x4b, 0x64,
	0xc3, 0xfc, 0x6b, 0x37, 0x4c, 0x49, 0xbb, 0xa6, 0x7c, 0xda, 0xb8, 0x57, 0xbb, 0x6b, 0xe1, 0xff,
	0x43, 0xe3, 0x11, 0x0b, 0x5e, 0xba, 0x41, 0x44, 0xb2, 0x70, 0x6c, 0x98, 0x1f, 0x05, 0xc7, 0xc7,
	0x3a, 0x9c, 0xa5, 0xbe, 0x36, 0xf0, 0x0e, 0xc0, 0x73, 0x26, 0xb2, 0x2b, 0xcb, 0x4c, 0x9f, 0x30,
	0xee, 0x4d, 0x32, 0x2d, 0xd7, 0x78, 0x17, 0x56, 0xf7, 0x42, 0x41, 0x38, 0x75, 0x05, 0xf9, 0x8c,
	0xf9, 0xcc, 0x40, 0x63, 0x57, 0x0c, 0xf3, 0x02, 0x70, 0xc5, 0x10, 0x6f, 0xc2, 0xc6, 0xd3, 0x98,
	0x13, 0xd7, 0x4b, 0x86, 0x01, 0x17, 0x67, 0x52, 0xbe, 0x0e, 0xf6, 0xd4, 0xd6, 0x5e, 0x18, 0x66,
	0xfe, 0x7b, 0xb0, 0xf1, 0x34, 0xaf, 0xb5, 0x27, 0xa1, 0x3b, 0x0e, 0x83, 0x44, 0xe8, 0x64, 0x6f,
	0xc3, 0x85, 0x38, 0x73, 0x1c, 0x06, 0x3a, 0xa6, 0x7a, 0x1f, 0x26, 0xae, 0x03, 0x0f, 0x7f, 0x0c,
	0xb6, 0x39, 0xfb, 0x8c, 0xbb, 0x83, 0x91, 0x3e, 0xb8, 0x09, 0x8b, 0x42, 0x5a, 0xe6, 0xd4, 0x79,
	0x65, 0x1f, 0x78, 0xf8, 0x27, 0x0b, 0x9a, 0x7d, 0x32, 0x20, 0x42, 0xb8, 0x82, 0xf1, 0xbc, 0x4c,
	0x13, 0x42, 0x34, 0x74, 0xae, 0xaf, 0xd6, 0x68, 0x17, 0x5a, 0x91, 0x1b, 0xd0, 0xc3, 0x80, 0xfa,
	0x9c, 0x78, 0x01, 0xa1, 0x22, 0x51, 0x39, 0xae, 0xf7, 0x9b, 0xd2, 0x7f, 0x60, 0xdc, 0xe8, 0x0e,
	0xac, 0x25, 0x64, 0xc0, 0xa8, 0xe7, 0xf2, 0xf1, 0x19, 0xfc, 0x9c, 0xc2, 0xdb, 0xf9, 0xe6, 0xf4,
	0x21, 0x1b, 0xe6, 0x13, 0x41, 0xe2, 0xa4, 0x5d, 0x57, 0x20, 0x6d, 0xe0, 0xdf, 0x2c, 0xb0, 0xa7,
	0xa3, 0x9b, 0xe0, 0x65, 0x88, 0xd4, 0x8d, 0xc8, 0x24, 0xd9, 0x72, 0x8d, 0x1c, 0x58, 0x7c, 0x95,
	0xba, 0x54, 0x04, 0x62, 0x9c, 0x3d, 0x7f, 0x6e, 0xcb, 0x3a, 0x8d, 0x88, 0x18, 0x32, 0x4f, 0x05,
	0xb1, 0xd4, 0xcf, 0x2c, 0xe9, 0xf7, 0x09, 0xf5, 0x08, 0x57, 0xba, 0x4b, 0xfd, 0xcc, 0x92, 0x5c,
	0x51, 0x1a, 0x8a, 0x20, 0x0e, 0x49, 0x7b, 0x7e, 0xc7, 0xba, 0xb1, 0xd8, 0xcf, 0x6d, 0xa9, 0x3d,
	0x0a, 0xa8, 0xd7, 0x5e, 0xd0, 0xda, 0x72, 0x8d, 0x6e, 0xc2, 0x8a, 0x8c, 0xe1, 0xd0, 0xa5, 0xde,
	0x61, 0x1e, 0xc4, 0x79, 0x05, 0x68, 0xca, 0x8d, 0x3d, 0xea, 0x7d, 0x91, 0xb9, 0xf1, 0xcf, 0x35,
	0x68, 0x99, 0x4b, 0x99, 0x62, 0x14, 0x81, 0x08, 0x27, 0x37, 0xd2, 0x86, 0x0c, 0x2f, 0x26, 0x4c,
	0x06, 0xa1, 0x73, 0x9d, 0x59, 0x2a, 0x3c, 0x97, 0x8f, 0x3c, 0x76, 0x42, 0xb3, 0x0b, 0xe5, 0xf6,
	0x74, 0x26, 0x55, 0x59, 0x2b, 0x03, 0x3d, 0x9e, 0xf1, 0x7e, 0xf3, 0xea, 0x67, 0x78, 0xad, 0xf8,
	0x33, 0x9c, 0x95, 0xf0, 0xf2, 0x2b, 0x7f, 0x5d, 0xf5, 0xca, 0x0b, 0xff, 0x82, 0x75, 0x76, 0x2d,
	0x4c, 0xea, 0xef, 0xbc, 0xa9, 0xbf, 0xdb, 0xbf, 0x34, 0x60, 0xe1, 0xa9, 0x62, 0x42, 0x14, 0x1a,
	0xd9, 0x17, 0x73, 0x9f, 0x0e, 0xe4, 0x02, 0x6d, 0x15, 0xc5, 0xa6, 0xbf, 0xba, 0xce, 0xe5, 0x8a,
	0xdd, 0xec, 0x07, 0xb7, 0xfd, 0xed, 0xef, 0x7f, 0xfd, 0x58, 0xdb, 0xc4, 0xb6, 0xea, 0x26, 0x23,
	0xbd, 0xd7, 0x23, 0x9a, 0xfa, 0x9e, 0x75, 0x73, 0x4a, 0xef, 0x01, 0xf9, 0xcf, 0xf4, 0x3c, 0x92,
	0xeb, 0x11, 0x00, 0xf3, 0x25, 0x47, 0xdb, 0x45, 0xb6, 0x42, 0x33, 0x70, 0x76, 0xaa, 0x01, 0xba,
	0x0d, 0x60, 0x5b, 0x29, 0x36, 0xf0, 0x92, 0x52, 0x14, 0xf1, 0x98, 0x49, 0x99, 0x7d, 0xa8, 0x3f,
	0x09, 0xa8, 0x8f, 0xec, 0xe2, 0x79, 0xd9, 0xd6, 0x9c, 0x92, 0x57, 0x36, 0x39, 0xbc, 0xa2, 0x98,
	0x2e, 0x20, 0xcd, 0x14, 0xcb, 0xe3, 0x2f, 0x60, 0x29, 0xef, 0x13, 0x15, 0x5c, 0xa5, 0x2b, 0x14,
	0x1b, 0xcb, 0xba, 0xa2, 0x6d, 0xa1, 0x86, 0xa2, 0xf5, 0x72, 0xba, 0xfb, 0x50, 0xbf, 0xcf, 0xc9,
	0x49, 0x05, 0x2d, 0xca, 0xbd, 0xaa, 0x6f, 0x4b, 0x64, 0x21, 0x40, 0xe9, 0x47, 0xaf, 0x00, 0x4c,
	0x63, 0x29, 0xa7, 0xb3, 0xd0, 0xd1, 0xca, 0xe9, 0x2c, 0x76, 0x25, 0xbc, 0xa3, 0x34, 0x1c, 0xd4,
	0x56, 0x1a, 0x34, 0xdf, 0xee, 0xbd, 0xd1, 0xeb, 0x53, 0x34, 0x04, 0x30, 0xe5, 0x5e, 0x96, 0x2c,
	0x7c, 0x6f, 0xcb, 0x92, 0xc5, 0xaf, 0x03, 0xde, 0x50, 0x92, 0x2b, 0xa8, 0xa9, 0x24, 0xb9, 0xe1,
	0x7e, 0x0e, 0x8b, 0x93, 0xae, 0x56, 0x91, 0xa5, 0x4e, 0xd1, 0x7b, 0xb6, 0x0b, 0xe2, 0x35, 0x45,
	0xdd, 0x44, 0xcb, 0x8a, 0x3a, 0x9a, 0x90, 0x25, 0xb0, 0x52, 0xea, 0x5c, 0x15, 0x0a, 0xd7, 0x8b,
	0xde, 0xaa, 0x96, 0x97, 0x55, 0x3e, 0xda, 0x50, 0x52, 0x89, 0x41, 0xf5, 0xb8, 0xe6, 0x7f, 0x09,
	0x8d, 0xb3, 0x3d, 0xb1, 0x42, 0xf1, 0xda, 0x07, 0x14, 0x4d, 0x27, 0xdd, 0x52, 0x72, 0xeb, 0xc8,
	0x2e, 0xc9, 0xb9, 0x61, 0x88, 0x1e, 0x42, 0x5d, 0xf6, 0xf9, 0x0a, 0x05, 0xa7, 0xe8, 0x35, 0x33,
	0x41, 0xa1, 0xc6, 0x4e, 0x24, 0x89, 0x0f, 0xcb, 0x67, 0x46, 0x82, 0x0a, 0xd6, 0xab, 0x45, 0xef,
	0x8c, 0x39, 0x02, 0x5f, 0x52, 0xf4, 0x6b, 0x68, 0x55, 0x4f, 0xb7, 0x13, 0xc4, 0xad, 0x50, 0xf2,
	0xbe, 0x80, 0x8b, 0xa6, 0xc3, 0x3f, 0xaa, 0x7a, 0xf3, 0xb6, 0xf1, 0x9a, 0xb1, 0xf5, 0xcb, 0x84,
	0x70, 0xec, 0x28, 0x72, 0x1b, 0x21, 0x9d, 0x13, 0x33, 0xdf, 0x46, 0x04, 0x45, 0xb0, 0x5a, 0x9e,
	0x3c, 0x92, 0x0a, 0x89, 0xcb, 0xb3, 0x24, 0xf2, 0x43, 0xf8, 0x8a, 0xd2, 0xb9, 0x84, 0x36, 0x8b,
	0x3a, 0x71, 0xce, 0xfb, 0x9d, 0x05, 0xa8, 0xac, 0x87, 0xca, 0xd5, 0x34, 0x7b, 0x1a, 0x72, 0xb6,
	0x3e, 0x14, 0x01, 0xee, 0xa9, 0x00, 0x76, 0xd1, 0xf5, 0xca, 0x00, 0x7a, 0x6f, 0xa6, 0x86, 0xa9,
	0x53, 0xe4, 0x41, 0xab, 0x30, 0x3b, 0x25, 0xff, 0x5c, 0x1b, 0x46, 0x58, 0x9f, 0xc0, 0x1d, 0x25,
	0xdb, 0x46, 0xeb, 0x45, 0x59, 0xa1, 0x19, 0x4f, 0xa1, 0x59, 0x50, 0x41, 0xd7, 0xaa, 0x2f, 0x6c,
	0x46, 0x38, 0x67, 0xb3, 0x52, 0x14, 0xef, 0x2a, 0xcd, 0xab, 0xe8, 0xca, 0x6c, 0xcd, 0xde, 0x9b,
	0xc9, 0xec, 0x77, 0xfa, 0x49, 0xf7, 0xd7, 0x77, 0x1d, 0xeb, 0xed, 0xbb, 0x8e, 0xf5, 0xe7, 0xbb,
	0x8e, 0xf5, 0xc3, 0xfb, 0xce, 0xb9, 0xb7, 0xef, 0x3b, 0xe7, 0xfe, 0x78, 0xdf, 0x39, 0xf7, 0xc2,
	0x4e, 0x43, 0xc1, 0x49, 0x37, 0x22, 0xbd, 0x4c, 0x47, 0x92, 0x1d, 0x2d, 0xa8, 0xff, 0x75, 0xee,
	0xfc, 0x1d, 0x00, 0x00, 0xff, 0xff, 0x4d, 0x1b, 0x28, 0xa4, 0x8f, 0x0d, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// ServerClient is the client API for Server service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type ServerClient interface {
	KryptosEncrypt(ctx context.Context, in *KryptosInput, opts ...grpc.CallOption) (*KryptosOutput, error)
	KryptosDecrypt(ctx context.Context, in *KryptosInput, opts ...grpc.CallOption) (*KryptosOutput, error)
	TpyoEnocde(ctx context.Context, in *TpyoEnocdeIpunt, opts ...grpc.CallOption) (*TpyoEnocdeOuptut, error)
	Ping(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Pong, error)
	Dashboard(ctx context.Context, in *Void, opts ...grpc.CallOption) (*DashboardOutput, error)
	Crew(ctx context.Context, in *Void, opts ...grpc.CallOption) (*crew.Crew, error)
	Numberinfo(ctx context.Context, in *NumberinfoInput, opts ...grpc.CallOption) (*NumberinfoOutput, error)
	Recettator(ctx context.Context, in *RecettatorInput, opts ...grpc.CallOption) (*RecettatorOutput, error)
	Moijaime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*MoijaimeOutput, error)
	SpreadshirtRandom(ctx context.Context, in *Void, opts ...grpc.CallOption) (*SpreadshirtRandomOutput, error)
	SpreadshirtAll(ctx context.Context, in *Void, opts ...grpc.CallOption) (*SpreadshirtAllOutput, error)
	Wotd(ctx context.Context, in *Void, opts ...grpc.CallOption) (*WotdOutput, error)
	AlternateLogo(ctx context.Context, in *Void, opts ...grpc.CallOption) (*AlternateLogoOutput, error)
	SoundcloudMe(ctx context.Context, in *Void, opts ...grpc.CallOption) (*soundcloud.User, error)
	SoundcloudPlaylists(ctx context.Context, in *Void, opts ...grpc.CallOption) (*soundcloud.Playlists, error)
	SoundcloudPlaylist(ctx context.Context, in *SoundcloudPlaylistInput, opts ...grpc.CallOption) (*soundcloud.Playlist, error)
	SoundcloudTracks(ctx context.Context, in *Void, opts ...grpc.CallOption) (*soundcloud.Tracks, error)
	SoundcloudTrack(ctx context.Context, in *SoundcloudTrackInput, opts ...grpc.CallOption) (*soundcloud.Track, error)
}

type serverClient struct {
	cc *grpc.ClientConn
}

func NewServerClient(cc *grpc.ClientConn) ServerClient {
	return &serverClient{cc}
}

func (c *serverClient) KryptosEncrypt(ctx context.Context, in *KryptosInput, opts ...grpc.CallOption) (*KryptosOutput, error) {
	out := new(KryptosOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/KryptosEncrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) KryptosDecrypt(ctx context.Context, in *KryptosInput, opts ...grpc.CallOption) (*KryptosOutput, error) {
	out := new(KryptosOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/KryptosDecrypt", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) TpyoEnocde(ctx context.Context, in *TpyoEnocdeIpunt, opts ...grpc.CallOption) (*TpyoEnocdeOuptut, error) {
	out := new(TpyoEnocdeOuptut)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/TpyoEnocde", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Ping(ctx context.Context, in *Void, opts ...grpc.CallOption) (*Pong, error) {
	out := new(Pong)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Ping", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Dashboard(ctx context.Context, in *Void, opts ...grpc.CallOption) (*DashboardOutput, error) {
	out := new(DashboardOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Dashboard", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Crew(ctx context.Context, in *Void, opts ...grpc.CallOption) (*crew.Crew, error) {
	out := new(crew.Crew)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Crew", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Numberinfo(ctx context.Context, in *NumberinfoInput, opts ...grpc.CallOption) (*NumberinfoOutput, error) {
	out := new(NumberinfoOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Numberinfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Recettator(ctx context.Context, in *RecettatorInput, opts ...grpc.CallOption) (*RecettatorOutput, error) {
	out := new(RecettatorOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Recettator", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Moijaime(ctx context.Context, in *Void, opts ...grpc.CallOption) (*MoijaimeOutput, error) {
	out := new(MoijaimeOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Moijaime", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SpreadshirtRandom(ctx context.Context, in *Void, opts ...grpc.CallOption) (*SpreadshirtRandomOutput, error) {
	out := new(SpreadshirtRandomOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SpreadshirtRandom", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SpreadshirtAll(ctx context.Context, in *Void, opts ...grpc.CallOption) (*SpreadshirtAllOutput, error) {
	out := new(SpreadshirtAllOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SpreadshirtAll", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) Wotd(ctx context.Context, in *Void, opts ...grpc.CallOption) (*WotdOutput, error) {
	out := new(WotdOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/Wotd", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) AlternateLogo(ctx context.Context, in *Void, opts ...grpc.CallOption) (*AlternateLogoOutput, error) {
	out := new(AlternateLogoOutput)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/AlternateLogo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SoundcloudMe(ctx context.Context, in *Void, opts ...grpc.CallOption) (*soundcloud.User, error) {
	out := new(soundcloud.User)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SoundcloudMe", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SoundcloudPlaylists(ctx context.Context, in *Void, opts ...grpc.CallOption) (*soundcloud.Playlists, error) {
	out := new(soundcloud.Playlists)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SoundcloudPlaylists", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SoundcloudPlaylist(ctx context.Context, in *SoundcloudPlaylistInput, opts ...grpc.CallOption) (*soundcloud.Playlist, error) {
	out := new(soundcloud.Playlist)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SoundcloudPlaylist", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SoundcloudTracks(ctx context.Context, in *Void, opts ...grpc.CallOption) (*soundcloud.Tracks, error) {
	out := new(soundcloud.Tracks)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SoundcloudTracks", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *serverClient) SoundcloudTrack(ctx context.Context, in *SoundcloudTrackInput, opts ...grpc.CallOption) (*soundcloud.Track, error) {
	out := new(soundcloud.Track)
	err := c.cc.Invoke(ctx, "/calcbiz.server.Server/SoundcloudTrack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ServerServer is the server API for Server service.
type ServerServer interface {
	KryptosEncrypt(context.Context, *KryptosInput) (*KryptosOutput, error)
	KryptosDecrypt(context.Context, *KryptosInput) (*KryptosOutput, error)
	TpyoEnocde(context.Context, *TpyoEnocdeIpunt) (*TpyoEnocdeOuptut, error)
	Ping(context.Context, *Void) (*Pong, error)
	Dashboard(context.Context, *Void) (*DashboardOutput, error)
	Crew(context.Context, *Void) (*crew.Crew, error)
	Numberinfo(context.Context, *NumberinfoInput) (*NumberinfoOutput, error)
	Recettator(context.Context, *RecettatorInput) (*RecettatorOutput, error)
	Moijaime(context.Context, *Void) (*MoijaimeOutput, error)
	SpreadshirtRandom(context.Context, *Void) (*SpreadshirtRandomOutput, error)
	SpreadshirtAll(context.Context, *Void) (*SpreadshirtAllOutput, error)
	Wotd(context.Context, *Void) (*WotdOutput, error)
	AlternateLogo(context.Context, *Void) (*AlternateLogoOutput, error)
	SoundcloudMe(context.Context, *Void) (*soundcloud.User, error)
	SoundcloudPlaylists(context.Context, *Void) (*soundcloud.Playlists, error)
	SoundcloudPlaylist(context.Context, *SoundcloudPlaylistInput) (*soundcloud.Playlist, error)
	SoundcloudTracks(context.Context, *Void) (*soundcloud.Tracks, error)
	SoundcloudTrack(context.Context, *SoundcloudTrackInput) (*soundcloud.Track, error)
}

func RegisterServerServer(s *grpc.Server, srv ServerServer) {
	s.RegisterService(&_Server_serviceDesc, srv)
}

func _Server_KryptosEncrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KryptosInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).KryptosEncrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/KryptosEncrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).KryptosEncrypt(ctx, req.(*KryptosInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_KryptosDecrypt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KryptosInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).KryptosDecrypt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/KryptosDecrypt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).KryptosDecrypt(ctx, req.(*KryptosInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_TpyoEnocde_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TpyoEnocdeIpunt)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).TpyoEnocde(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/TpyoEnocde",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).TpyoEnocde(ctx, req.(*TpyoEnocdeIpunt))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Ping(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Dashboard_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Dashboard(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Dashboard",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Dashboard(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Crew_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Crew(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Crew",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Crew(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Numberinfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NumberinfoInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Numberinfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Numberinfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Numberinfo(ctx, req.(*NumberinfoInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Recettator_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RecettatorInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Recettator(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Recettator",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Recettator(ctx, req.(*RecettatorInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Moijaime_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Moijaime(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Moijaime",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Moijaime(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SpreadshirtRandom_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SpreadshirtRandom(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SpreadshirtRandom",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SpreadshirtRandom(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SpreadshirtAll_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SpreadshirtAll(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SpreadshirtAll",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SpreadshirtAll(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_Wotd_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).Wotd(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/Wotd",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).Wotd(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_AlternateLogo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).AlternateLogo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/AlternateLogo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).AlternateLogo(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SoundcloudMe_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SoundcloudMe(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SoundcloudMe",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SoundcloudMe(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SoundcloudPlaylists_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SoundcloudPlaylists(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SoundcloudPlaylists",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SoundcloudPlaylists(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SoundcloudPlaylist_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SoundcloudPlaylistInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SoundcloudPlaylist(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SoundcloudPlaylist",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SoundcloudPlaylist(ctx, req.(*SoundcloudPlaylistInput))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SoundcloudTracks_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Void)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SoundcloudTracks(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SoundcloudTracks",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SoundcloudTracks(ctx, req.(*Void))
	}
	return interceptor(ctx, in, info, handler)
}

func _Server_SoundcloudTrack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SoundcloudTrackInput)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ServerServer).SoundcloudTrack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/calcbiz.server.Server/SoundcloudTrack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ServerServer).SoundcloudTrack(ctx, req.(*SoundcloudTrackInput))
	}
	return interceptor(ctx, in, info, handler)
}

var _Server_serviceDesc = grpc.ServiceDesc{
	ServiceName: "calcbiz.server.Server",
	HandlerType: (*ServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "KryptosEncrypt",
			Handler:    _Server_KryptosEncrypt_Handler,
		},
		{
			MethodName: "KryptosDecrypt",
			Handler:    _Server_KryptosDecrypt_Handler,
		},
		{
			MethodName: "TpyoEnocde",
			Handler:    _Server_TpyoEnocde_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _Server_Ping_Handler,
		},
		{
			MethodName: "Dashboard",
			Handler:    _Server_Dashboard_Handler,
		},
		{
			MethodName: "Crew",
			Handler:    _Server_Crew_Handler,
		},
		{
			MethodName: "Numberinfo",
			Handler:    _Server_Numberinfo_Handler,
		},
		{
			MethodName: "Recettator",
			Handler:    _Server_Recettator_Handler,
		},
		{
			MethodName: "Moijaime",
			Handler:    _Server_Moijaime_Handler,
		},
		{
			MethodName: "SpreadshirtRandom",
			Handler:    _Server_SpreadshirtRandom_Handler,
		},
		{
			MethodName: "SpreadshirtAll",
			Handler:    _Server_SpreadshirtAll_Handler,
		},
		{
			MethodName: "Wotd",
			Handler:    _Server_Wotd_Handler,
		},
		{
			MethodName: "AlternateLogo",
			Handler:    _Server_AlternateLogo_Handler,
		},
		{
			MethodName: "SoundcloudMe",
			Handler:    _Server_SoundcloudMe_Handler,
		},
		{
			MethodName: "SoundcloudPlaylists",
			Handler:    _Server_SoundcloudPlaylists_Handler,
		},
		{
			MethodName: "SoundcloudPlaylist",
			Handler:    _Server_SoundcloudPlaylist_Handler,
		},
		{
			MethodName: "SoundcloudTracks",
			Handler:    _Server_SoundcloudTracks_Handler,
		},
		{
			MethodName: "SoundcloudTrack",
			Handler:    _Server_SoundcloudTrack_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "api/api.proto",
}

func (m *Void) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Void) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *Pong) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Pong) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Pong) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Pong)))
		i += copy(dAtA[i:], m.Pong)
	}
	return i, nil
}

func (m *KryptosInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KryptosInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.From) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.From)))
		i += copy(dAtA[i:], m.From)
	}
	return i, nil
}

func (m *KryptosOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KryptosOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	return i, nil
}

func (m *TpyoEnocdeIpunt) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TpyoEnocdeIpunt) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Form) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Form)))
		i += copy(dAtA[i:], m.Form)
	}
	return i, nil
}

func (m *TpyoEnocdeOuptut) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TpyoEnocdeOuptut) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.To) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.To)))
		i += copy(dAtA[i:], m.To)
	}
	return i, nil
}

func (m *DahsboardRandomOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DahsboardRandomOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DahsboardOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DahsboardOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *DashboardOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *DashboardOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *NumberinfoInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberinfoInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Number != 0 {
		dAtA[i] = 0xd
		i++
		encoding_binary.LittleEndian.PutUint32(dAtA[i:], uint32(math.Float32bits(float32(m.Number))))
		i += 4
	}
	return i, nil
}

func (m *NumberinfoOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *NumberinfoOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Facts) > 0 {
		for k, _ := range m.Facts {
			dAtA[i] = 0xa
			i++
			v := m.Facts[k]
			mapSize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			i = encodeVarintApi(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintApi(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	return i, nil
}

func (m *MoijaimeOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MoijaimeOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kiffs) > 0 {
		for _, s := range m.Kiffs {
			dAtA[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	return i, nil
}

func (m *WotdOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *WotdOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Word) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Word)))
		i += copy(dAtA[i:], m.Word)
	}
	return i, nil
}

func (m *AlternateLogoOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AlternateLogoOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Path)))
		i += copy(dAtA[i:], m.Path)
	}
	return i, nil
}

func (m *SpreadshirtRandomOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadshirtRandomOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SpreadshirtAllOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SpreadshirtAllOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *SoundcloudPlaylistInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoundcloudPlaylistInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.PlaylistId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.PlaylistId))
	}
	return i, nil
}

func (m *SoundcloudTrackInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *SoundcloudTrackInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.TrackId != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.TrackId))
	}
	return i, nil
}

func (m *RecettatorInput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecettatorInput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seed != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Seed))
	}
	if m.MainIngredients != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.MainIngredients))
	}
	if m.SecondaryIngredients != 0 {
		dAtA[i] = 0x18
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.SecondaryIngredients))
	}
	if m.Steps != 0 {
		dAtA[i] = 0x20
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Steps))
	}
	return i, nil
}

func (m *RecettatorIngredient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecettatorIngredient) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Quantity) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Quantity)))
		i += copy(dAtA[i:], m.Quantity)
	}
	if len(m.Method) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Method)))
		i += copy(dAtA[i:], m.Method)
	}
	if len(m.Gender) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Gender)))
		i += copy(dAtA[i:], m.Gender)
	}
	if m.Multiple {
		dAtA[i] = 0x28
		i++
		if m.Multiple {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if len(m.Kind) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.NameAndQuantity) > 0 {
		dAtA[i] = 0x3a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.NameAndQuantity)))
		i += copy(dAtA[i:], m.NameAndQuantity)
	}
	return i, nil
}

func (m *RecettatorOutput) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *RecettatorOutput) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Title) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Title)))
		i += copy(dAtA[i:], m.Title)
	}
	if m.People != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.People))
	}
	if len(m.Markdown) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintApi(dAtA, i, uint64(len(m.Markdown)))
		i += copy(dAtA[i:], m.Markdown)
	}
	if len(m.Steps) > 0 {
		for _, s := range m.Steps {
			dAtA[i] = 0x22
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.MainIngredients) > 0 {
		for _, msg := range m.MainIngredients {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.SecondaryIngredients) > 0 {
		for _, msg := range m.SecondaryIngredients {
			dAtA[i] = 0x32
			i++
			i = encodeVarintApi(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Seed != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintApi(dAtA, i, uint64(m.Seed))
	}
	return i, nil
}

func encodeVarintApi(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *Void) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *Pong) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Pong)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *KryptosInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.From)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *KryptosOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TpyoEnocdeIpunt) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Form)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *TpyoEnocdeOuptut) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.To)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *DahsboardRandomOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DahsboardOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *DashboardOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *NumberinfoInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Number != 0 {
		n += 5
	}
	return n
}

func (m *NumberinfoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Facts) > 0 {
		for k, v := range m.Facts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovApi(uint64(len(k))) + 1 + len(v) + sovApi(uint64(len(v)))
			n += mapEntrySize + 1 + sovApi(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *MoijaimeOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Kiffs) > 0 {
		for _, s := range m.Kiffs {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	return n
}

func (m *WotdOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Word)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *AlternateLogoOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *SpreadshirtRandomOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SpreadshirtAllOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	return n
}

func (m *SoundcloudPlaylistInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.PlaylistId != 0 {
		n += 1 + sovApi(uint64(m.PlaylistId))
	}
	return n
}

func (m *SoundcloudTrackInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.TrackId != 0 {
		n += 1 + sovApi(uint64(m.TrackId))
	}
	return n
}

func (m *RecettatorInput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seed != 0 {
		n += 1 + sovApi(uint64(m.Seed))
	}
	if m.MainIngredients != 0 {
		n += 1 + sovApi(uint64(m.MainIngredients))
	}
	if m.SecondaryIngredients != 0 {
		n += 1 + sovApi(uint64(m.SecondaryIngredients))
	}
	if m.Steps != 0 {
		n += 1 + sovApi(uint64(m.Steps))
	}
	return n
}

func (m *RecettatorIngredient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Quantity)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Method)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.Gender)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.Multiple {
		n += 2
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	l = len(m.NameAndQuantity)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	return n
}

func (m *RecettatorOutput) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Title)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if m.People != 0 {
		n += 1 + sovApi(uint64(m.People))
	}
	l = len(m.Markdown)
	if l > 0 {
		n += 1 + l + sovApi(uint64(l))
	}
	if len(m.Steps) > 0 {
		for _, s := range m.Steps {
			l = len(s)
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.MainIngredients) > 0 {
		for _, e := range m.MainIngredients {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if len(m.SecondaryIngredients) > 0 {
		for _, e := range m.SecondaryIngredients {
			l = e.Size()
			n += 1 + l + sovApi(uint64(l))
		}
	}
	if m.Seed != 0 {
		n += 1 + sovApi(uint64(m.Seed))
	}
	return n
}

func sovApi(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozApi(x uint64) (n int) {
	return sovApi(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Void) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Void: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Void: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Pong) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Pong: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Pong: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Pong", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Pong = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KryptosInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KryptosInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KryptosInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field From", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.From = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KryptosOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KryptosOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KryptosOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TpyoEnocdeIpunt) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TpyoEnocdeIpunt: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TpyoEnocdeIpunt: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Form", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Form = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TpyoEnocdeOuptut) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TpyoEnocdeOuptut: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TpyoEnocdeOuptut: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field To", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.To = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DahsboardRandomOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DahsboardRandomOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DahsboardRandomOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DahsboardOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DahsboardOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DahsboardOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DashboardOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DashboardOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DashboardOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumberinfoInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberinfoInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberinfoInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 5 {
				return fmt.Errorf("proto: wrong wireType = %d for field Number", wireType)
			}
			var v uint32
			if (iNdEx + 4) > l {
				return io.ErrUnexpectedEOF
			}
			v = uint32(encoding_binary.LittleEndian.Uint32(dAtA[iNdEx:]))
			iNdEx += 4
			m.Number = float32(math.Float32frombits(v))
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NumberinfoOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NumberinfoOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NumberinfoOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Facts == nil {
				m.Facts = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowApi
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowApi
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= (uint64(b) & 0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthApi
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipApi(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthApi
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Facts[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MoijaimeOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MoijaimeOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MoijaimeOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kiffs", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kiffs = append(m.Kiffs, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WotdOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WotdOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WotdOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Word", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Word = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AlternateLogoOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AlternateLogoOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AlternateLogoOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadshirtRandomOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadshirtRandomOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadshirtRandomOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SpreadshirtAllOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SpreadshirtAllOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SpreadshirtAllOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoundcloudPlaylistInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoundcloudPlaylistInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoundcloudPlaylistInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PlaylistId", wireType)
			}
			m.PlaylistId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PlaylistId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SoundcloudTrackInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SoundcloudTrackInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SoundcloudTrackInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TrackId", wireType)
			}
			m.TrackId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TrackId |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecettatorInput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecettatorInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecettatorInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainIngredients", wireType)
			}
			m.MainIngredients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.MainIngredients |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIngredients", wireType)
			}
			m.SecondaryIngredients = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.SecondaryIngredients |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			m.Steps = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Steps |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecettatorIngredient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecettatorIngredient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecettatorIngredient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Quantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Quantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Method", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Method = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Gender", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Gender = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Multiple", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Multiple = bool(v != 0)
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NameAndQuantity", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NameAndQuantity = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RecettatorOutput) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowApi
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RecettatorOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RecettatorOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Title", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Title = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field People", wireType)
			}
			m.People = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.People |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Markdown", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Markdown = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Steps", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Steps = append(m.Steps, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MainIngredients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MainIngredients = append(m.MainIngredients, &RecettatorIngredient{})
			if err := m.MainIngredients[len(m.MainIngredients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SecondaryIngredients", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthApi
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SecondaryIngredients = append(m.SecondaryIngredients, &RecettatorIngredient{})
			if err := m.SecondaryIngredients[len(m.SecondaryIngredients)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seed", wireType)
			}
			m.Seed = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowApi
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seed |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipApi(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthApi
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipApi(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowApi
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowApi
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthApi
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowApi
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipApi(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthApi = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowApi   = fmt.Errorf("proto: integer overflow")
)
